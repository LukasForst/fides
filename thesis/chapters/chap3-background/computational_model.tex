\section{Computational Model of Fides}
\label{sec:computational-model}
This section describes how does Fides come up with a single most important value $st_{i,j}$ service trust. Service trust describes how much can local peer $i$ trust remote peer $j$.
Used algorithm, that computes $st_{i,j}$, is based on SORT\cite{sort} with modifications to fit our use case - a global peer-to-peer network for sharing threat intelligence. 
The modifications are based on the interaction evaluation strategies proposed in \ref{sec:interaction-evaluation-strategies} and algorithms to solve cold start problem described in \ref{sec:cold-start-problem}. The table \ref{tab:notation-computational-model} describes the most important notation we use in the following sections.

\begin{table}[ht]
\centering
\begin{tabular}{ c | m{20em} }
 $i$ & local peer, instance of Fides \\
 \hline
 $j$ & remote peer somewhere on the internet \\
 \hline
 $st_{i, j}$ & service trust - how much $i$ trusts $j$ that it provides good service \\
 \hline
 $r_{i, j}$ & $i$'s reputation value about $j$ \\
 \hline
 $rt_{i, j}$ & $i$'s recommendation trust about $j$ \\
 \hline
 $sh_{i, j}$ & size of $i$'s service history with $j$ \\
 \hline
 $s^{k}_{i, j}$ & $i$'s satisfaction value with interaction with peer $j$ in window $k$\\
 \hline
 $w^{k}_{i, j}$ & weight of $i$'s interaction with $j$ in $k$ \\
 \hline
 $f^{k}_{i, j}$ & fading effect of $i$'s interaction with $j$ in $k$ \\
\end{tabular}
\caption{Fides Computational Model Notation}
\label{tab:notation-computational-model}
\end{table}

\subsection{Intuition}
In the following pages, we describe the process top-down starting with the most important parts - service trust - and then breaking it down to bits.
There are two main ideas behind the most of the equations. 

The first one is that we want to robustly capture average behavior of the peers. In order to do that, we will be computing average behavior and standard deviations from said behavior and normalizing them.

Secondly, we will be comparing and weighting first hand experience with the remote experience. 
First hand experience is what happened between local and remote peer during time they interacted. This can be, for example, threat intelligence sharing, file sharing or the results of recommendation protocol.
Remote experience is what happened between one remote peer and another remote peer. In other words, first hand experience for peer $j$ are actions between $j$ and $z$. When $j$ shares information about these action with peer $i$, for $i$ it is a remote experience.

\subsection{Service Trust}
\label{subsec:service-trust}
One of the major goals of the algorithm is to compute the service trust $st_{i,j}$. 
Service trust is a value that describes how much does peer $i$ trust remote peer $j$, that it is going to provide \textit{good service}.
We compute the value by weighting local experience with peer's $j$ service, with the reputation $j$ got from the network, when it was first seen by $i$.
The used weight is the size of the service interaction history $sh_{i,j}$ to maximal history size $sh_{max}$.

\begin{equation}
\label{eq:service-trust}
    st_{i,j}=\frac{sh_{i,j}}{sh_{max}} \cdot \left(cb_{i,j} - \frac{1}{2} ib_{i,j} \right) +\left(1-\frac{sh_{i,j}}{sh_{max}}\right) \cdot r_{i,j}
\end{equation}

The service trust equation (\ref{eq:service-trust}) implies that the more interaction there was, between $i$ and $j$, the bigger impact on $st_{i,j}$ it has. 
In other words, the more $i$ and $j$ interact the less $i$ rely on the reputation, that $i$ computed from the values provided by the network, at the time when $j$ was seen for the first time and it 

\subsection{Local Experience for Service Trust}
First part of the equation \ref{eq:service-trust} contains \textit{competence belief}, $cb_{i,j}$, and $ib_{i,j}$ - \textit{integrity belief}.
Both of the values are based solely on the interactions history that peer $i$ experienced with the peer $j$.

\subsubsection{Competence Belief}
\textit{Competence belief} represents how much did peer $j$ satisfy local peer $i$ with the past interactions. We measure it as an average of interactions from the past \cite{sort}.
\begin{equation}
\begin{split}
    cb_{i,j} &= \frac{1}{\beta_{cb}} \sum_{k=1}^{sh_{i, j}} s_{i,j}^{k} \cdot w_{i,j}^{k} \cdot f_{i,j}^{k} \\
    \beta_{cb} &= \sum_{k=1}^{sh_{i, j}} s_{i,j}^{k} \cdot w_{i,j}^{k}
\end{split}
\end{equation}
It holds that $0 \leq cb_{i,j} \leq 1$ and where $s^{k}_{i,j}$ is the evaluation of the interaction in window $k$, $w^{k}_{i, j}$ is the weight of the interaction (how important it was) and $f^{k}_{i,j}$ is the fading effect of that interaction. We describe $s^{k}_{i,j}$, $w^{k}_{i,j}$ and $f^{k}_{i,j}$ in greater detail in \ref{subsec:evaluating-an-interaction}. 
$\beta_{cb}$ is the normalization coefficient that ensures that $cb_{i, j}$ stays within the interval of $0 \leq cb_{i,j} \leq 1$.

\subsubsection{Integrity Belief}
\textit{Integrity belief} is a level of confidence in predictability of future interactions. $ib_{i,j}$ is then measured as deviation from the average behavior $cb_{i,j}$. 
Therefore, $ib_{i,j}$ is calculated as an approximation to the standard deviation of interaction parameters\cite{sort}.
\begin{equation}
\begin{split}
    ib_{i,j} &= \sqrt{\frac{1}{sh_{i,j}} \sum_{k=1}^{sh_{i,j}}\left(s_{i,j}^{k} \cdot w_{i,j}^{\mu} \cdot f_{i,j}^{\mu} - cb_{i,j}\right)^{2}} \\
    f_{i,j}^{\mu} &= \frac{1}{sh_{i, j}} \sum_{k=1}^{sh_{i,j}} f^{k}_{i,j} \\
    w_{i,j}^{\mu} &= \frac{1}{sh_{i, j}} \sum_{k=1}^{sh_{i,j}} w^{k}_{i,j}
\end{split}
\end{equation}

It holds that $0 \leq ib_{i,j} \leq 1$.
The more consistent behavior peer $j$ has, the lower the $ib_{i,j}$ is. Consistency is highly desired property as the local peer then have more precise estimates about future behavior of the remote peer.

\subsection{Evaluating an Interaction}
\label{subsec:evaluating-an-interaction}
\todo{Should we keep it here or move somewhere else?}
In section \ref{sec:interaction-evaluation-strategies}, we describe multiple strategies in detail, how to compute $s^{k}_{i,j}$ - satisfaction value with $k$th interaction of the local peer $i$ with peer $j$.
However, not all interactions are same - some of the interactions are more important then the others. 
Moreover, because peers can change their behavior, most recent interactions should be more important the the interactions that happened long time ago.

\subsubsection{Weight of the Interaction}
Because each interaction is different and its importance is different, we have $w^{k}_{i,j}$ that measures the importance.
Weight belongs to interval $0 \leq w^{k}_{i,j} \leq 1$ and Fides implements it as a discrete function of interaction type. 
For example, weight of interaction when remote peer shares the threat intelligence is higher, then when the peer sends threat intelligence request.


\subsubsection{Fading Effect}
Fading effect $f^{k}_{i,j}$ determines \textit{"how much does algorithm forget"} as the algorithm prefers most recent interactions over past interactions and thus $f^{k}_{i,j}$ reduces weight of the past interactions. 
$f^{k}_{i,j}$ is a \textit{non-increasing function} of interaction and time, or an index of said interaction in the history.
This depends on the implementation - Fides implements it as a decreasing linear function.
\begin{equation}
    f^{k}_{i,j} = \frac{k}{sh_{i,j}}, 1 \leq k \leq sh_{i,j}
\end{equation}
However, it can be implemented as a function of time as well. In that case, the function does not depend on $k$ (as an index of a time window) bur rather on the time, when the interaction happened.

\subsection{Reputation and Recommendations}
In order to mitigate cold start problem outlined in section \ref{sec:cold-start-problem} and in cases when there are no or little interactions between $i$ and $j$, the algorithm relies on $r_{i,j}$ - \textit{reputation value}. 
$r_{i,j}$ is the second part of the service trust equation \ref{eq:service-trust} that introduces \textit{remote experience} to the service trust.

\textit{Reputation} value is computed from the \textit{recommendations} received from the remote peers. This value represents what do remote peers think about another remote peer. However, this value is calculated by the local peer with respect, how much it trusts each peer, that provided the recommendation.
When the local peer $i$ encounters remote peer $j$ for the first time and it does not have any data about its trustworthiness, $i$ can request recommendations on peer $j$ from $i$'s most trusted peers.
We denote a set of remote peers, that provided the recommendations as $T_{i}$.

\subsubsection{Requesting a Recommendation}
The recommendation system build into Fides can not be used in every scenario.
Because of the sensitive nature of the environment, the trust model was designed for, there are cases when it is dangerous to ask for the recommendations.
That is mainly the case, when there are \textit{not enough} peers that are \textit{trusted enough}.

SORT \cite{sort} requests recommendations every time it encounters a new peer. Set of recommending peers is created by taking all known peers and selecting the ones, that have higher then average service trust.
However, those can also be peers with trust as low as $0.001$. In a sensitive environment, which peer-to-peer network of IPS definitely is, we do not want to get recommendations from peers, that have low trust at all.
Moreover, given the nature of Slips, we decided to combine recommendation system based on SORT with static initial trust \ref{subsec:static-initial-trust} and with pre-trusted peers \ref{subsec:pre-trusted-peers}. 
This approach gives us more robust basis for trust sensitive environment and it helps us to mitigate cold start problem \ref{sec:cold-start-problem}.\todo{This is again too text heavy, should we leave that here, or move that somewhere else?}

If the peer is part of pre-trusted organization or it is pre-trusted itself, it inherits the configured reputation - $r_{i, j}$ from the configuration.
In this case, Fides does not engage recommendation protocol at all, because the peer already has reputation $r_{i,j}$ assigned from the configuration and it was \textit{recommended} by the administrator.
Moreover, the administrator can choose if this value is \textit{frozen}, or not. \textit{Frozen} configuration means, that the peer $j$ has in eyes of $i$ \textit{static service trust} $st_{i, j}$ - it will never change and whatever data peer $j$ sends to $i$ will not influence the $st_{i,j}$.

\subsubsection{Recommendation Response}
A single recommendation response from peer $z \in T_{i}$ about giving recommendation to peer $i$ about peer $j$ contains following data.
\begin{itemize}
    \item $cb_{z,j}$, $ib_{z,j}$ - summary of $z$'s interactions with $j$, competence belief and integrity belief
    \item $sh_{z,j}$ - service history size, number of the interactions between $z$ and $j$ - the more interactions they had, then the $z$'s recommendation has more credibility
    \item $r_{z, j}$ - summary of recommendations that $z$ received on $j$
    \item $\eta_{z,j}$ - number of peers that provided recommendations for $j$ when $j$ was new to $z$ and their recommendation was used to compute $r_{z,j}$
\end{itemize}

\todo{Do we need to explain why did we added all these properties to a single recommendation? Original paper does that, but I'm not sure if we need to do that or not.}

\subsubsection{Computing Reputation}
\label{subsubsec:computing-reputation}
When the local peer receives all recommendations, it computes reputation value $r_{i,j}$ as a weighted expected local experience ($ecb_{i,j}$, $eib_{i,j}$ - estimates about competence and integrity) from the remote peers with their remote experience ($er_{i,j}$ - estimate about reputation of said peer).

\begin{equation}
\label{eq:reputation-value}
\begin{split}
    r_{i, j}=\frac{\lfloor\mu_{sh}\rfloor}{sh_{max}} \cdot \left(ecb_{i,j}-\frac{1}{2} eib_{i, j}\right) + \left(1-\frac{\lfloor\mu_{sh}\rfloor}{sh_{max}}\right) \cdot er_{i,j}
\end{split}
\end{equation}

\noindent
The weight, used in equation \ref{eq:reputation-value}, is the average of history sizes in all recommendations to $sh_{max}$, maximal interactions history size. 
We calculate $\mu_{sh}$ as follows.
\begin{equation}
    \mu_{sh} = \frac{1}{|T_{i}|} \sum_{z \in T_{i}} sh_{z, j}
\end{equation}
\noindent
Again, we are weighting local experience to remote experience. However, in this case it is local for remote peers that provided the recommendations.

\subsection{Remote Local Experience}
\label{subsec:remote-local-experience}
\todo{This name is weird}
Similarly as when we compute service trust in \ref{eq:service-trust}, we need to get competence and integrity belief.
However, while creating reputation value in \ref{eq:reputation-value} where the values are coming from the remote peers, we are trying to estimate those values received from the network.
For that reason, we call them \textit{estimated competence belief} - $ecb_{i,j}$ and \textit{estimated integrity belief} - $eib_{i,j}$.

\subsubsection{Estimated Competence Belief}
$ecb_{i,j}$ is estimation about competence belief made by $i$ about $j$. 
This value is computed from the received recommendations in combination with $rt_{i,z}$ - a \textit{recommendation trust} that $i$ has about $z$.
Similarly as for service trust, we have a normalization coefficient $\beta_{ecb}$ that moves the resulting data to correct interval.
It holds that $0 \leq ecb_{i,j} \leq 1$.

\begin{equation}
\label{eq:estimated-competence-belief}
\begin{split}
    ecb_{i,j} &= \frac{1}{\beta_{ecb}} \sum_{z \in T_{i}} \left(rt_{i, z} \cdot sh_{z, j} \cdot cb_{z, j}\right) \\
    \beta_{ecb} &= \sum_{z \in T_{i}} \left(rt_{i, z} \cdot sh_{z, j}\right)
\end{split}
\end{equation}

\noindent
Recommendation trust $rt_{i, z}$ is described in detail in section \ref{subsec:recommendation-trust-metric}.

\subsubsection{Estimated Integrity Belief}
Following the $ecb_{i,j}$, $eib_{i,j}$ is estimation about the integrity belief made by $i$ about $j$.
The equation is almost similar, but we use $ib_{z,j}$ instead of $eb_{z,j}$.
This means that normalization coefficient $\beta_{eib} = \beta_{ecb}$.

\begin{equation}
\label{eq:estimated-integrity-belief}
\begin{split}
    eib_{i,j} &= \frac{1}{\beta_{eib}} \sum_{z \in T_{i}} \left(rt_{i, z} \cdot sh_{z, j} \cdot ib_{z, j}\right) \\
    \beta_{eib} &= \sum_{z \in T_{i}} \left(rt_{i, z} \cdot sh_{z, j}\right)
\end{split}
\end{equation}

\subsection{Remote Remote Experience}
Going back to equation \ref{eq:reputation-value} from section \ref{subsubsec:computing-reputation}, we use \textit{estimated reputation value} - $er_{i,j}$.
This value represents information that was created by the peers, that are remote even for remote peer $j$. 
Essentially making it an information that came from the \textit{second ring of trust} - from an acquaintances of an acquaintance.

\begin{equation}
\label{eq:estimated-reputation}
\begin{split}
    er_{i,j} &= \frac{1}{\beta_{er}} \sum_{z \in T_{i}} \left(rt_{i, z} \cdot \eta_{z, j} \cdot r_{z, j}\right) \\
    \beta_{er} &= \sum_{z \in T_{i}} \left(rt_{i, z} \cdot \eta{z, j}\right)
\end{split}
\end{equation}

\subsection{Recommendation Trust Metric}
\label{subsec:recommendation-trust-metric}
Recommendation trust - $rt_{i,z}$ - is another metric that a peers calculate and store. It expresses how much does $i$ trust $z$, that it provides \textit{good recommendations}.
Even though one could theoretically use service trust $st_{i, z}$ for this,
we have another trust metric, because there are peers that can provide very good data (service), but they have very bad taste on other peers, or other way around.
This also gives us the ability to have specialized nodes in the network, that serve as a peers registry for organizations - a single node that only provides recommendations on peers.

We calculate recommendation trust in a similar way as the service trust and reputation, but we use recommendation competence belief $rcb_{i, z}$, recommendation integrity belief $rib_{i,z}$ and reputation $r_{i, z}$.
This time, used weight is $rh_{i,z}$, which is size of the recommendations history provided by $z$ to $i$, and $rh_{max}$, a maximal size of said history.

\begin{equation}
\label{eq:recommendation-trust}
\begin{split}
    rt_{i, z} = \frac{rh_{i,z}}{rh_{max}} \left(rcb_{i,z} - \frac{1}{2} rib_{i, z} \right) + \left(1 - \frac{rh_{i,z}}{rh_{max}} \right) r_{i,z}
\end{split}
\end{equation}

\subsubsection{Recommendation Competence and Integrity Belief}
\label{subsubsec:recommendation-competence-integrity-belief}
Similar for interactions, we use three different parameters for calculating the $rcb_{i, z}$ and $rib_{i,z}$. 
We use satisfaction $rs^{x}_{i, z}$, weight $rw^{x}_{i, z}$ and the fading effect $rf^{x}_{i, z}$. 
The parameters have the same background as described in section \ref{subsec:evaluating-an-interaction}, but in this case they are connected to recommendations instead of service.
We calculate $rcb_{i, z}$ as follows:

\begin{equation}
\begin{split}
    rcb_{i, z} &= \frac{1}{\beta_{rcb}} \sum_{x = 1}^{rh_{i, z}}\left(rs_{i,z}^{x} \cdot rw_{i, z}^{x} \cdot rf_{i,z}^{x}\right) \\
    \beta_{rcb} &= \sum_{x = 1}^{rh_{i, z}}\left(rw_{i, z}^{x} \cdot rf_{i,z}^{x}\right)
\end{split}
\end{equation}

\noindent
And for recommendation integrity we compute $rib_{i, z}$ as:
\begin{equation}
    rib_{i, z} = \sqrt{\frac{1}{rh_{i, z}} \sum_{x=1}^{rh_{i,z}} \left(rs_{i,z}^{x} \cdot rw_{i, z}^{\mu} \cdot rf_{i,z}^{\mu} - rcb_{i,z}\right)^{2}}
\end{equation}

\noindent
One more time, the computational model is trying to approximate average behavior in recommendations - $rcb_{i,z}$ - and its standard deviation from such behavior - $rib_{i,z}$.

\subsubsection{Evaluating Received Recommendation}
As outlined in section \ref{subsubsec:recommendation-competence-integrity-belief}, in order to evaluate particular recommendation from remote peer $z$, we have satisfaction, weight and fading effect. 
We calculate recommendation satisfaction $rs^{x}_{i,z}$ by comparing values from $z$'s recommendation $r_{z,j}$, $cb_{z,j}$, $ib_{z,j}$, with values that are the results of the the recommendation algorithm.
In other words, we compare each recommendation, with the aggregated values - $er_{i,j}$, $ecb_{i,j}$ and $eib_{i,j}$. This gives us estimate how off, was the peer $z$'s recommendation from the final result of the recommendation algorithm.

\begin{equation}
\begin{split}
    rs^{x}_{i,z} = \frac{1}{3} \left[ \left(1-\frac{\left|r_{z, j} - er_{i,j}\right|}{er_{i,j}}\right) + \left(1 - \frac{\left|cb_{z, j} - ecb_{i, j}\right|}{ecb_{i, j}}\right) + \left(1 - \frac{\left|ib_{z, j} - eib_{i, j}\right|}{eib_{i, j}}\right) \right]
\end{split}
\end{equation}
\todo{This seems to be too wide, make it smaller}

We calculate weight of recommendation $rw^{x}_{i,z}$ as a weighted sum of proportion of size of thee service history between $z$ and $j$ with maximal service history size. And number of peers that provided the initial reputations $\eta_{z,j}$ divided by maximal number of possible recommending peers.
\begin{equation}
    rw^{x}_{i,z} = \frac{\lfloor\mu_{sh}\rfloor}{sh_{max}} \cdot \frac{sh_{z, j}}{sh_{max}} + \left(1 - \frac{\lfloor\mu_{sh}\rfloor}{sh_{max}}\right) \cdot \frac{\eta_{z,j}}{\eta_{max}}
\end{equation}

Fading effect $rf^{x}_{i, z}$ has similar properties as the fading effect for service trust described in section \ref{subsec:evaluating-an-interaction}. It is a non-increasing function of number of recommendation or time. 
For the recommendations, Fides implements it exactly the same as for the service interactions, thus $rf^{x}_{i, z} = \frac{x}{rh_{i, z}}, 1 \leq x \leq rh_{i,z}$.
